Generates bindings to COM interfaces, enums and coclasses.


# Usage

See the `test-msxml` subdirectory for a full example of using this library to generate bindings for the MSXML library.

1. Find the `.tlb`, or `.dll` with an embedded `.tlb` resource, for the COM library that you want to generate the bindgen output for. If it can be [`#import`ed in MSVC](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-import-directive-cpp) then it should work with `winapi-tlb-bindgen`

1. Write a build script that uses this crate to generate the bindgen output for the COM library.

	```rust
	// build.rs

	winapi_tlb_bindgen::build(
		std::path::Path::new(r"C:\Program Files (x86)\Windows Kits\10\Lib\10.0.16299.0\um\x64\MsXml.Tlb"),
		false,
		out_file, // $OUT_DIR/msxml.rs
	).unwrap();
	```

1. Add an empty mod file that `include!`s the bindgen output.

	```rust
	// src/msxml.rs

	include!(concat!(env!("OUT_DIR"), "/msxml.rs"));
	```

1. Add a dependency to your crate on [`winapi = { version = "0.3.x" }`](https://docs.rs/winapi/0.3.x/x86_64-pc-windows-msvc/winapi/) You will likely want to enable (atleast) the `objbase`, `oleauto`, and `winerror` features to get access to `HRESULT`, `IUnknown` and other COM types.

1. Build your crate.

1. Silence warnings for identifier names and unused functions as necessary, and prepend imports from winapi for any types the compiler can't find.

	```rust
	// src/msxml.rs

	#![allow(non_camel_case_types, non_snake_case, unused)]

	use winapi::shared::guiddef::GUID;
	use winapi::shared::minwindef::UINT;
	use winapi::shared::winerror::HRESULT;
	use winapi::shared::wtypes::{BSTR, VARIANT_BOOL};
	use winapi::um::oaidl::{IDispatch, IDispatchVtbl, LPDISPATCH, VARIANT};
	use winapi::um::unknwnbase::{IUnknown, IUnknownVtbl, LPUNKNOWN};

	include!(concat!(env!("OUT_DIR"), "/msxml.rs"));
	```

	Repeat till there are no more missing imports and the crate compiles.

	([Issue #2](https://github.com/Arnavion/winapi-tlb-bindgen/issues/2) is about automating this step or atleast making it easier.)

1. Compare the output against [the C++ headers generated by MSVC with `#import`.](https://docs.microsoft.com/en-us/cpp/preprocessor/hash-import-directive-cpp#_predir_the_23import_directive_header_files_created_by_import) File a bug if something was emitted incorrectly.

1. Enjoy your COM API bindings.

	```rust
	// src/main.rs

	#[macro_use]
	extern crate winapi;

	mod msxml;

	fn main() {
		unsafe {
			let hr = winapi::um::objbase::CoInitialize(std::ptr::null_mut());
			assert!(winapi::shared::winerror::SUCCEEDED(hr));

			let mut document: *mut winapi::ctypes::c_void = std::ptr::null_mut();
			let hr =
				winapi::um::combaseapi::CoCreateInstance(
					&msxml::DOMDocument::uuidof(),
					std::ptr::null_mut(),
					winapi::um::combaseapi::CLSCTX_ALL,
					&<msxml::IXMLDOMDocument as winapi::Interface>::uuidof(),
					&mut document,
				);
			assert!(winapi::shared::winerror::SUCCEEDED(hr));
			let document = &*(document as *mut msxml::IXMLDOMDocument);

			// ...

			document.Release();
		}
	}
	```


# `winapi-tlb-bindgen-bin`

The `winapi-tlb-bindgen-bin` crate is a binary that takes in the path of the typelib as a command-line parameter, and writes the bindgen output to stdout. This can be used to generate bindings manually for greater control, as opposed to using a build script to automatically generate the bindings on every build.

```powershell
cd winapi-tlb-bindgen-bin
cargo run -- 'C:\Program Files (x86)\Windows Kits\10\Lib\10.0.16299.0\um\x64\MsXml.Tlb'
```
